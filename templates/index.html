<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Forex Simulation Chart</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #131722;
            color: #d1d4dc;
            font-family: -apple-system, BlinkMacSystemFont, "Trebuchet MS", Roboto, Ubuntu, sans-serif;
            overflow: hidden;
        }
        #chart {
            width: 100vw;
            height: 100vh;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #ffffff;
            display: none;
        }

        /* Trade Tooltip */
        .trade-tooltip {
            position: absolute;
            background-color: rgba(19, 23, 34, 0.95);
            border: 1px solid #485c7b;
            padding: 8px;
            border-radius: 4px;
            display: none;
            z-index: 200;
            pointer-events: none;
            font-size: 12px;
            line-height: 1.5;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .trade-highlight {
            position: absolute;
            border-radius: 50%;
            display: none;
            z-index: 199;
            pointer-events: none;
            /* enlarged size handled in JS or class */
            width: 12px;
            height: 12px;
            margin-left: -6px;
            margin-top: -6px;
            border: 2px solid white;
        }
        
        /* Measure Tool Styles */
        .measure-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            padding: 8px 16px;
            background-color: #2962ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        .measure-btn:hover {
            opacity: 1;
        }
        .measure-btn.active {
            background-color: #0039cb;
            box-shadow: 0 0 0 2px rgba(41, 98, 255, 0.5);
        }

        .measure-box {
            position: absolute;
            background-color: rgba(41, 98, 255, 0.2);
            border: 1px solid #2962ff;
            display: none;
            pointer-events: none; /* Let clicks pass through if needed, but we intercept on container */
            z-index: 50;
        }

        .measure-label {
            position: absolute;
            background-color: #2962ff;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 51;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <button id="measureBtn" class="measure-btn">Measure</button>
    <div id="measureBox" class="measure-box"></div>
    <div id="measureLabel" class="measure-label"></div>
    <div id="tradeTooltip" class="trade-tooltip"></div>
    <div id="tradeHighlight" class="trade-highlight"></div>
    <div id="loading" class="loading">Loading data...</div>
    <div id="chart"></div>

    <script>
        const chartElement = document.getElementById('chart');
        const loadingElement = document.getElementById('loading');
        
        // Show loading
        loadingElement.style.display = 'block';

        // Create Chart
        const chartOptions = { 
            layout: { 
                textColor: '#d1d4dc', 
                background: { type: 'solid', color: '#131722' } 
            },
            grid: {
                vertLines: { color: '#363c4e' },
                horzLines: { color: '#363c4e' }
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
                borderColor: '#485c7b',
            },
            rightPriceScale: {
                borderColor: '#485c7b',
            },
        };
        const chart = LightweightCharts.createChart(chartElement, chartOptions);

        const candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
            upColor: '#26a69a', 
            downColor: '#ef5350', 
            borderVisible: false, 
            wickUpColor: '#26a69a', 
            wickDownColor: '#ef5350', 
        });

        // Trade Series (Longs and Shorts)
        const longSeries = chart.addSeries(LightweightCharts.LineSeries, {
            color: '#26a69a',
            lineWidth: 0,
            pointMarkersVisible: true,
            pointMarkersRadius: 4, 
            pointMarkersCanvasArc: true,
            lineVisible: false,
            crosshairMarkerVisible: false,
        });

        const shortSeries = chart.addSeries(LightweightCharts.LineSeries, {
            color: '#ef5350',
            lineWidth: 0,
            pointMarkersVisible: true,
            pointMarkersRadius: 4,
            pointMarkersCanvasArc: true,
            lineVisible: false,
            crosshairMarkerVisible: false,
        });

        // Resize handler
        window.addEventListener('resize', () => {
            chart.applyOptions({ width: window.innerWidth, height: window.innerHeight });
        });

        let allTrades = [];

        // Fetch Data
        Promise.all([
             fetch('/api/data').then(r => r.json()),
             fetch('/api/trades').then(r => r.json())
        ]).then(([candleData, tradeData]) => {
                candlestickSeries.setData(candleData);
                
                // Process trades
                allTrades = tradeData;
                const longs = [];
                const shorts = [];
                
                // Sort trades by time just in case, though usually DB handles it.
                // Lightweight charts strict about order.
                allTrades.sort((a, b) => a.time - b.time);

                allTrades.forEach(t => {
                   // Ensure unique time? 
                   // If same timestamp, we drop it? Or add epsilon.
                   // Simple fix: if multiple items have same time, shift slightly if possible logic wise, 
                   // but here just pushing. Lightweight Charts might error if exact duplicates on same series.
                   // We'll see.
                   
                   const point = { time: t.time, value: t.entry_price };
                   if (t.position_type.toLowerCase() === 'long') {
                       longs.push(point);
                   } else {
                       shorts.push(point);
                   }
                });

                // Deduping for series (simple approach: last wins)
                // Helper to dedup by time
                const dedup = (arr) => {
                    const seen = new Set();
                    return arr.filter(item => {
                        const k = item.time;
                        return seen.has(k) ? false : seen.add(k);
                    });
                };

                longSeries.setData(dedup(longs));
                shortSeries.setData(dedup(shorts));

                loadingElement.style.display = 'none';
                chart.timeScale().fitContent();
        })
        .catch(err => {
            console.error(err);
            loadingElement.innerText = "Error loading data.";
        });

        // --- Measure Tool Logic ---
        const measureBtn = document.getElementById('measureBtn');
        const measureBox = document.getElementById('measureBox');
        const measureLabel = document.getElementById('measureLabel');

        let isMeasureMode = false;
        let isDrawing = false;
        let startPoint = null; // { time, price }
        let endPoint = null;   // { time, price }

        measureBtn.addEventListener('click', toggleMeasureMode);

        function toggleMeasureMode() {
            // If we are cancelling mode, clear everything unless we have a persistent measurement
            // But requirement says "stays until we click randomly".
            // So toggling button just enters/exits the "ready to measure" state.
            isMeasureMode = !isMeasureMode;
            measureBtn.classList.toggle('active', isMeasureMode);
            
            if (isMeasureMode) {
                chartElement.style.cursor = 'crosshair';
                // Disable chart scrolling while measuring is active? 
                // Usually TradingView allows scroll unless you are dragging.
                // We'll handle drag suppression in mousedown.
            } else {
                chartElement.style.cursor = 'default';
                // Clear measurement when explicitly turning off? 
                // Or maybe just exit mode. Let's just exit mode.
            }
        }

        // Mouse Events
        chartElement.addEventListener('mousedown', (e) => {
            if (!isMeasureMode && !measureBox.style.display === 'block') {
                // If not in mode and no box showing, do nothing special
                return;
            }

            // Click outside logic: if we have a box and click, dismiss it.
            if (!isMeasureMode && measureBox.style.display !== 'none') {
                clearMeasurement();
                return;
            }

            if (isMeasureMode) {
                isDrawing = true;
                chart.applyOptions({ handleScroll: false, handleScale: false });
                
                const coordinate = chart.timeScale().coordinateToTime(e.offsetX);
                const price = candlestickSeries.coordinateToPrice(e.offsetY);
                
                // We need the logical index or time object depending on data.
                // coordinateToTime returns a time stamp or object.
                // coordinateToPrice returns price.
                
                startPoint = { time: coordinate, price: price };
                endPoint = { time: coordinate, price: price }; // Init end point
                
                updateMeasureBoxDisplay();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDrawing && startPoint) {
                // We need coordinates relative to chartElement
                const rect = chartElement.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const time = chart.timeScale().coordinateToTime(x);
                const price = candlestickSeries.coordinateToPrice(y);
                
                if (time !== null && price !== null) {
                    endPoint = { time: time, price: price };
                    updateMeasureBoxDisplay();
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                isMeasureMode = false; // Exit mode after drawing one measurement
                measureBtn.classList.remove('active');
                chartElement.style.cursor = 'default';
                chart.applyOptions({ handleScroll: true, handleScale: true });
            }
        });

        function clearMeasurement() {
            measureBox.style.display = 'none';
            measureLabel.style.display = 'none';
            startPoint = null;
            endPoint = null;
        }

        function updateMeasureBoxDisplay() {
            if (!startPoint || !endPoint) return;

            // Convert logical to coordinates
            const timeScale = chart.timeScale();
            
            // Note: timeToCoordinate might return null if out of range, 
            // but we want to draw it anyway if possible.
            // If time is object (business days), it must match exactly or close.
            // Lightweight charts handle this usually.
            
            const x1 = timeScale.timeToCoordinate(startPoint.time);
            const y1 = candlestickSeries.priceToCoordinate(startPoint.price);
            
            const x2 = timeScale.timeToCoordinate(endPoint.time);
            const y2 = candlestickSeries.priceToCoordinate(endPoint.price);

            if (x1 === null || y1 === null || x2 === null || y2 === null) return;

            const left = Math.min(x1, x2);
            const top = Math.min(y1, y2);
            const width = Math.abs(x2 - x1);
            const height = Math.abs(y2 - y1);

            measureBox.style.left = left + 'px';
            measureBox.style.top = top + 'px';
            measureBox.style.width = width + 'px';
            measureBox.style.height = height + 'px';
            measureBox.style.display = 'block';

            // Calculate differences
            const priceDiff = endPoint.price - startPoint.price;
            const pricePct = (priceDiff / startPoint.price) * 100;
            
            // Time diff is tricky with business days / raw timestamps.
            // Assuming we deal with unix timestamps mostly or string dates. 
            // For simple difference, we might need the index or just display raw.
            // Let's try to get simple timestamp diff if numbers.
            let timeText = '';
            if (typeof startPoint.time === 'number' && typeof endPoint.time === 'number') {
                // Assuming UX timestamp seconds
                const diffSeconds = endPoint.time - startPoint.time;
                const bars = 0; // Hard to calc bars without access to all data indices easily
                timeText = `${Math.abs(diffSeconds / 60).toFixed(0)}m`; 
            } else {
                 // If it's date string, just show nothing or raw.
                 timeText = ''; 
            }

            measureLabel.innerHTML = `
                ${priceDiff.toFixed(5)} (${pricePct.toFixed(2)}%)<br>
                ${timeText}
            `;
            measureLabel.style.left = (left + width / 2) + 'px';
            measureLabel.style.top = (top - 30) + 'px';
            measureLabel.style.display = 'block';
        }

        // Subscribe to changes to keep box position updated during scroll/zoom
        chart.timeScale().subscribeVisibleTimeRangeChange(() => {
            if (startPoint && endPoint) {
                updateMeasureBoxDisplay();
            }
        });

        // Trade Tooltip Logic
        const tradeTooltip = document.getElementById('tradeTooltip');
        const tradeHighlight = document.getElementById('tradeHighlight');

        chartElement.addEventListener('mousemove', (e) => {
            if (isMeasureMode) return;
            if (e.buttons > 0) return; // Skip if dragging

            const rect = chartElement.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            let nearest = null;
            let minDistance = 20; // proximity threshold in pixels

            const timeScale = chart.timeScale();
            // Check all trades
            for (const t of allTrades) {
                const x = timeScale.timeToCoordinate(t.time);
                const y = candlestickSeries.priceToCoordinate(t.entry_price);
                
                if (x === null || y === null) continue;

                const dist = Math.sqrt(Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2));
                if (dist < minDistance) {
                    minDistance = dist;
                    nearest = { trade: t, x, y };
                }
            }

            if (nearest) {
                const t = nearest.trade;
                const isLong = t.position_type.toLowerCase() === 'long';
                const color = isLong ? '#26a69a' : '#ef5350';
                
                tradeHighlight.style.display = 'block';
                tradeHighlight.style.left = nearest.x + 'px';
                tradeHighlight.style.top = nearest.y + 'px';
                tradeHighlight.style.borderColor = color;
                // Enlarge visual
                tradeHighlight.style.width = '14px'; 
                tradeHighlight.style.height = '14px';
                tradeHighlight.style.boxShadow = `0 0 5px ${color}`;

                tradeTooltip.style.display = 'block';
                tradeTooltip.style.left = (nearest.x + 15) + 'px';
                tradeTooltip.style.top = (nearest.y - 30) + 'px';
                tradeTooltip.innerHTML = `
                    <div style="font-weight:bold; margin-bottom:4px; border-bottom:1px solid #444; padding-bottom:2px;">#${t.position_id}</div>
                    <div style="color:${color}; font-weight:bold;">${t.position_type.toUpperCase()}</div>
                    <div>Entry: ${t.entry_price}</div>
                    <div>Exit: ${t.exit_price || '-'}</div>
                    <div>Lot: ${t.lot_size}</div>
                `;
            } else {
                tradeHighlight.style.display = 'none';
                tradeTooltip.style.display = 'none';
            }
        });

    </script>
</body>
</html>
